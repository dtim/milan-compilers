Архитектура компилятора JMilan
===============================

JMilan является компилятором учебного языка Милан, описанного в книге [1],
в код виртуальной машины Милана [2]. JMilan написан на языке Java и
представляет собой пример реализации простого компилятора без привлечения
дополнительных инструментов для построения трансляторов. Модификация этого
компилятора для поддержки расширений языка Милан является предметом курсовой
работы в курсах "Основы построения трансляторов" ФТК СПбГПУ и "Системное
программное обеспечение" факультета при ЦНИИ РТК СПбГПУ.

Компилятор включает следующие компоненты:

1. Лексический анализатор.
2. Синтаксический анализатор, совмещенный с генератором кода.
3. Модуль управления работой компилятора ("драйвер").

Также используется вспомогательный компонент, обеспечивающий
генерацию и буферизацию инструкций виртуальной машины.

Лексическиий анализатор
------------------------

Лексический анализатор читает исходный текст программы из файла и
последовательно возвращает лексемы, соответствующие элементарным единицам
программы на языке Милан. Он также отслеживает текущую позицию в файле для
того, чтобы при возникновении ошибки можно было сообщить ее положение
в тексте программы.

Набор лексем зафиксирован и представлен с помощью перечислимого типа Token.
Символы, которые не соответствуют ни одной лексеме, считаются ошибочными,
при их обнаружении лексический анализатор выдает сообщение об ошибке.
Всем ошибочным символам соответствует лексема Token.ILLEGAL.

Лексический анализатор представлен с помощью класса Scanner. Конструктор
этого класса принимает в качестве параметра имя файла, из которого будут
читаться символы. При вызове публичного метода nextToken() лексический
анализатор пробует продвинуться в потоке символов вперед, пока считанные
символы не составят одну лексему (если это невозможно, возвращается
либо Token.EOF, если был достигнут конец файла, либо Token.ILLEGAL
в случае ошибки). Если лексема соответствует корректному идентификатору
языка Милан, она проверяется на совпадение с ключевым словом.
В зависимости от результата проверки возвращается либо лексема
Token.IDENTIFIER, либо лексема, соответствующая ключевому слову. Регистр
символов в JMilan игнорируется, все идентификаторы и ключевые слова
приводятся к нижнему регистру.

Пробельные символы и комментарии в стиле C (/* .... */) пропускаются, но
считаются разделителями лексем. Одновременно с чтением символов из файла
производится подсчет номера текущей строки в файле. Лексический анализатор
предоставляет метод getLineNumber() для доступа на чтение к этому номеру.

После того, как лексема обнаружена, состояние лексического анализатора
не изменяется до следующего вызова nextToken(). При этом можно сколько
угодно раз читать значение текущей лексемы с помощью вызова метода token().

С некоторыми лексемами связаны атрибуты: с лексемой Token.NUMBER связано
числовое значение целочисленного литерала, а с лексемой Token.IDENTIFIER -
строковое значение идентификатора. Доступ к значениям этих атрибутов
обеспечивается с помощью методов intValue() и stringValue(). Для остальных
лексем значение, которое возвращают эти методы, не определено, равно как
не определено значение intValue(), если последней считанной лексемой
является Token.IDENTIFIER, и значение stringValue(), если последняя
считанная лексема - Token.NUMBER.

Таким образом, лексический анализатор можно считать конечным автоматом,
текущее состояние которого соответствует лексеме, которая последней
была считана из файла, а переходы между состояниями осуществляются при
чтении максимальной непрерывной последовательности символов, образующих
лексему. Анализатор позволяет узнать текущее состояние автомата и значения
атрибутов, определенных в этом состоянии.

Синтаксический анализатор
--------------------------

Синтаксический анализатор на основе грамматики языка Милан и потока лексем,
возвращаемых лексическим анализатором, строит последовательность инструкций
для виртуальной машины Милана. Синтаксический анализатор реализует алгоритм
рекурсивного спуска.

В JMilan синтаксический анализатор реализован в виде класса Parser.
При создании объекта конструктору Parser передается экземпляр
лексического анализатора и ссылка на поток, в который должны печататься
команды виртуальной машины.

Каждому нетерминальному символу грамматики Милана сопоставлен метод класса
Parser. Поскольку в реализуемой JMilan атрибутной грамматике используются
только синтезированные атрибуты, эти методы не имеют параметров.

Для того, чтобы начать синтаксический анализ с помощью созданного экземпляра
синтаксического анализатора, вызывается его метод parse(). Если в программе
нет синтаксических ошибок, в выходной поток печатается код программы
на языке ассемблера виртуальной машины.

Код генерируется в процессе разбора исходного текста. Инструкции, которые
генерируют код для каждой языковой конструкции, расположены в методах
синтаксического анализа соответствующих этим конструкциям нетерминальных
символов. Код не печатается в выходной поток сразу при его генерации,
вместо этого он сохраняется в буфере. Это позволяет, во-первых, не
печатать код при наличии ошибок, и, во-вторых, позволяет пропускать
некоторые команды, заполняя их правильными инструкциями на более поздних
этапах работы. Это необходимо, в частности, для генерации кода условных
операторов и циклов.

Код для условного оператора

IF условие THEN операторы1 ELSE операторы2 FI

имеет вид:

<код вычисления аргументов условия>
COMPARE <условие>
JUMP_NO <начало блока ELSE>
<операторы1> ; THEN
JUMP <следующий за блоком ELSE оператор>
<операторы2> ; ELSE

Чтобы сгенерировать этот код, необходимо знать адреса начала и конца
блока ELSE. Эти адреса становятся известными только после того,
как будет целиком сгенерирован код ветви ELSE. Поэтому вместо того,
чтобы генерировать инструкции JUMP_NO и JUMP, сначала вместо них
создаются пустые инструкции NOP, которые потом, когда адреса переходов
станут известными, заменяются на правильные инструкции переходов.
Код для оператора цикла генерируется аналогично.

Для генерации кода используется вспомогательный класс CodeEmitter,
который обеспечивает буферизацию инструкций и предоставляет функции
для отслеживания адресов инструкций и для записи инструкций в буфер.

Обработка ошибок осуществляется простым методом, идея которого заимствована
из компилятора j-- [3]. В синтаксическом анализаторе реализована служебная
функция mustBe(). Если текущая лексема не совпадает с образцом, переданным
mustBe в качестве параметра, устанавливается признак неправильности программы
(он нужен, чтобы метод parse() не возвращал некорректное дерево), а
синтаксический анализатор переходит в "невосстановленное" состояние. В этом
состоянии лексемы входного потока пропускаются до тех пор, пока не встретится
образец или признак конца файла. Если образец нашелся, синтаксический
анализатор переходит в нормальное состояние и продолжает работу. Этот способ
восстановления после ошибок является крайне примитивным, поскольку заключается
в простом пропускании всех лексем, не совпадающих с ожидаемым образцом,
может приводить к появлению "наведенных" ошибок, а также не обеспечивает
точной диагностики проблемы, но во многих случаях позволяет продолжить
работу и обнаружить другие ошибки в программе. Кроме того, этот метод
гарантирует завершение работы компилятора над ошибочной программой,
поскольку лексемы только удаляются из потока, но никогда не вставляются в него.
Признак неправильности программы устанавливается также в случаях, когда
ни один вариант правой части применяемого правила не может быть использован.
В этом случае выдается специализированное для каждого нетерминала сообщение
об ошибке.

Драйвер
--------

Задачами драйвера являются:
- анализ аргументов командной строки,
- определение режима работы компилятора (в текущей версии JMilan возможны два
  режима: печать справочного сообщения и компиляция программы),
- открытие и закрытие необходимых файловых потоков,
- запуск синтаксического анализатора и кодогенератора.

Драйвер реализован в методе main() класса Main.

Ссылки
=======

[1] Карпов Ю. Г. Основы построения трансляторов // СПб.: БХВ-Петербург, 2005
[2] http://dcn.infos.ru/~dtim/software/milan/
[3] http://www.cs.umb.edu/~wrc/cs651/spr09/index.html
