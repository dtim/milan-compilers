== Компилятор языка Милан ==

Содержание

1. Обзор базовой версии языка Милан
2. Архитектура компилятора
3. Лексический анализатор
4. Синтаксический анализатор
5. Абстрактное синтаксическое дерево
6. Генератор кода
7. Объединяем всё вместе

= 1. Обзор базовой версии языка Милан =

Предлагаемый в качестве основы курсового проекта компилятор реализует
базовую версию языка Милан.

Милан -- похожий на Паскаль язык программирования. Программа на Милане
представляет собой последовательность операторов. Как и в Паскале, операторы
отделяются друг от друга точкой с запятой. После последнего оператора в блоке
точку с запятой можно не ставить.

Программа начинается ключевым словом BEGIN и заканчивается ключевым словом END.

В Милан входят следующие конструкции:

1) Константы. Базовая версия Милана поддерживает только целочисленные константы,
перед которыми может идти знак '-', обозначающий отрицательное число.
Константы состоят из цифр. Примеры констант:

        0
        42
        -17

2) Идентификаторы (имена переменных). Они состоят из букв a-z и A-Z и цифр.
Идентификатор должен начинаться с буквы и иметь длину хотя бы один символ.
Максимальная длина идентификатора определяется реализацией и равна 63 символам.
Примеры идентификаторов:

        x
        Identifier
        rs232

В базовой версии языка Милан переменные хранят только целочисленные значения.

3) Арифметические выражения. Они включают знаки операций +, -, *, /, скобки
и аргументы: целые числа, имена переменных и функцию READ, которая возвращает
число, считанное со стандартного устройства ввода.

Примеры арифметических выражений:

        READ
        2 + 2
        X12
        1 + (X * 12 / Z) * (3 * READ)

Обратите внимание, что значения первого и последнего выражений зависят от того,
какое число введёт пользователь.

4) Оператор присваивания. Он имеет синтаксис:

        X := Y

Эта запись обозначает присваивание переменной X значения Y. Слева от
оператора ':=' должно стоять имя переменной, а справа -- арифметическое
выражение. Значение правой части вычисляется, и результат записывается
в переменную, имя которой находится слева от знака ':='.

Пробел между ':' и '=' не допускается.

5) Условный оператор. В языке Милан условный оператор имеет два варианта:

        IF условие THEN операторы FI

и
        IF условие THEN операторы1 ELSE операторы2 FI

Условие должно иметь вид

        X op Y

где "op" -- знак операции сравнения. Поддерживаются следующие операции:

        =               Равенство
        !=              Неравенство
        <               Меньше
        >               Больше
        <=              Меньше или равно
        >=              Больше или равно

Вместо "X" и "Y" в условии могут стоять произвольные арифметические
выражения. Вот примеры допустимых условий:

        x < y
        2 + 2 = 5
        i != 42

При выполнении условного оператора сначала вычисляются обе части условия и
производится их сравнение. Если условие истинно, выполняется блок операторов,
записанный после ключевого слова THEN. Если условие не выполняется и
в операторе присутствует блок ELSE, то выполняется он.
Например, в результате выполнения условного оператора

        IF 2 < 3
        THEN
                i := 2;
                j := 5
        FI

переменная i получит значение 2, а переменная j -- значение 5.
Результатом выполнения оператора

        IF 17 == 42
        THEN
                x := 1
        ELSE
                x := 5
        FI

будет присваивание переменной x значения 5, а при выполнении оператора

        IF 42 = 17
        TNEN
                x := 18
        FI

не будет произведено никаких действий, и переменная x сохранит своё исходное
значение.

5) Оператор цикла с предусловием. Он имеет вид:

        WHILE условие DO операторы OD

Условие записывается так же, как и в условном операторе.

При выполнении этого оператора проверяется условие. Блок операторов,
составляющих тело цикла, выполняется до тех пор, пока условие не станет
ложным. Условие вычисляется в начале каждой итерации.

Пример:

        i := 0;
        sum := 0;
        WHILE i <= 5 DO
                sum := sum + i;
                i := i + 1
        OD

В результате выполнения этого блока операторов в переменную sum будет
записано значение, равное сумме 0 + 1 + 2 + 3 + 4 + 5.

6) Оператор печати на стандартное устройство вывода:

        WRITE(E)

Аргументом оператора может быть любое арифметическое выражение.
Примеры:

        WRITE(42);
        WRITE(2 + 2);
        WRITE(x + READ * (2 + 3 / y));

Программы на языке Милан могут содержать комментарии, которые должны
начинаться с символов '/*' и заканчиваться '*/', как в языке C.
Комментарии не могут быть вложенными.

Приведём пример полной программы на языке Милан. Эта программа
запрашивает у пользователя число n и печатает на экране его факториал
n!:

        /* Факториал числа */

        BEGIN
                n := READ;
                fact := 1;

                WHILE n > 1 DO
                        fact := fact * n;
                        n := n - 1
                OD;

                WRITE(fact)
        END

Компилятор языка Милан чувствителен к регистру символов. Так, строка

        n := READ

интерпретируется как присваивание переменной n значения, считанного со
стандартного устройства ввода, а строка

        n := Read

как присваивание переменной n значения переменной Read. Служебные слова
BEGIN, END, IF, THEN, ELSE, FI, WHILE, DO, OD, WRITE также должны
записываться именно заглавными буквами, в противном случае компилятор
сообщит о синтаксической ошибке.

!!! -------------------------------------------------------------------
!!! Внимание! Нынешняя версия компилятора Милана не сообщает, в какой
!!! именно строке произошла ошибка!
!!!
!!! У Вас есть уникальная возможность исправить этот недостаток :)
!!! -------------------------------------------------------------------

= 2. Архитектура компилятора =

Компилятор Милана состоит из следующих модулей:

1) Лексический анализатор
2) Синтаксический анализатор
3) Модуль работы с абстрактным синтаксическим деревом
4) Модуль генерации кода для виртуальной машины Милана
5) Основной модуль, в котором функции предыдущих модулей
   вызываются в правильной последовательности.

Лексический анализатор преобразует поток символов, считанных из файла или
со стандартного ввода, в поток лексем (терминальных символов грамматики Милана).
Например, последовательность 'W' 'H' 'I' 'L' 'E' будет преобразована
лексическим анализатором Милана в лексему T_WHILE. С некоторыми лексемами
связывается дополнительная информация. Так, любое целое число будет
на выходе лексического анализатора будет представлено как лексема T_INT,
с которой будет связано значение числа. Аналогично, с лексемой T_IDENT
связывается имя переменной. Лексический анализатор также отвечает за
удаление комментариев.

Синтаксический анализатор выполняет синтаксический разбор потока лексем в
соответствии с грамматикой языка Милан. В процессе разбора синтаксический
анализатор строит промежуточную структуру данных, называемую деревом разбора.
В синтаксическом анализаторе также реализована обработка синтаксических ошибок.
В базовой версии компилятора обработка ошибок тривиальна: выводится сообщение
"syntax error" и компиляция прекращается. Имеет смысл доработать обработку
ошибок, обеспечив отслеживание строки и положения в строке, где обнаружена
ошибка, и продолжение компиляции, что позволит найти за один проход более
одной ошибки. Это может быть сделано в рамках курсовой работы, результат
которой будет включён в следующую версию компилятора Милана.

Дерево разбора -- это промежуточная структура данных, описывающая структуру
программы и удобная для автоматической обработки. Структура дерева разбора
близка к дереву, которое описывает процесс синтаксического анализа.
Его узлы не содержат лишних листьев (соответствующих терминальным символам),
но могут включать дополнительные данные (атрибуты). Компилятор такого простого
языка, как базовая версия Милана, можно построить и без использования явного
дерева разбора, но для реализации таких возможностей языка, как поддержка
областей видимости переменных, проверка или вывод типов, функции и процедуры,
наличие такой промежуточной структуры данных оказывается чрезвычайно удобным.

Дерево разбора, построенное в результате работы синтаксического анализатора,
используется компилятором Милана для генерации кода. Это делается путём
рекурсивного обхода дерева разбора и формирования цепочек команд,
соответствующих каждому узлу дерева.

Основной модуль программы обрабатывает параметры командной строки,
открывает необходимые файлы и вызывает функцию синтаксического анализа.
Если синтаксический разбор оказывается успешным, то есть программа не
содержит синтаксических ошибок, то вызываются функции генерации
кода и печати его в выходной файл. После этого файлы закрываются и
выполнение программы завершается.

Компилятор Милана поддерживает отладочную опцию командной строки
-D, которая инициирует печать дерева разбора. Используя эту
опцию, можно увидеть внутреннее представление программы и проверить
его соответствие исходному тексту.

= 3. Лексический анализатор =

Лексический анализатор компилятора Милана преобразует поток символов,
считанный из файла или стандартного потока ввода в поток лексем, который
затем будет подан на вход синтаксического анализатора.
Лексический анализатор работает в соответствии с грамматикой, на основе
которой производится разбор входного потока. Эта грамматика является
автоматной, поэтому лексический анализ Милана не представляет существенных
трудностей и мог бы быть легко реализован вручную как с использованием
известных методов кодирования программной реализации конечных автоматов,
так и с помощью существующих или написанной самостоятельно библиотек
работы с регулярными выражениями. Однако для удобства и простоты расширения
языка для построения лексического анализатора используется широко
распространённый генератор лексических анализаторов flex.

flex ('fast lex') -- это современное расширение программы lex, которая
используется для разработки лексических анализаторов, начиная с 1970-х
годов.

Программа flex читает описание лексического анализатора, написанное на
собственном проблемно-ориентированном языке, и генерирует исходный
текст лексического анализатора на языке C.

flex-описание лексического анализатора Милана находится в файле lexer.l.

Файл описания лексического анализатора состоит из трёх частей, отделяемых
друг от друга символами '%%':

        Раздел определений

        %%

        Раздел правил

        %%

        Раздел пользовательского кода

В разделе определений могут быть заданы параметры работы программы,
пользовательские фрагменты исходного текста, комментарии и определения
flex. 

Пользовательские фрагменты заключаются в "скобки":

        %{
        Исходный текст на языке C, который будет
        без изменения добавлен в построенный
        лексический анализатор
        %}

Комментарии, как и в языке C, помещаются между символами /* и */.

Определения позволяют давать имена регулярным выражениям и имеют вид:

        <имя>     <регулярное выражение>

Разделителем выступает один или более символов пробела или табуляции.
Приведём в качестве примера несколько определений из описания лексического
анализатора Милана:

        WHITESPACE	[ \t\n]+
        INT		[0-9]+
        IDENT		[a-zA-Z][_0-9a-zA-Z]*
        ASSIGN		:=

Как только имя определено, на него можно ссылаться, заключив его в
фигурные скобки. Имя в фигурных скобках заменяется на соответствующее
имени регулярное выражение. Например, {WHITESPACE} будет заменено на
[ \t\n]+ .

Рассмотрим некоторые элементы, которые могут входить в регулярное
выражение.

x               Символ 'x'

.               Любой символ, кроме символа конца строки

[xyz]           Класс символов. В данном случае образец совпадает
                с любым из символов x, y или z. Символы, имеющие
                специальное значение, обрабатываются внутри класса символов
                как обычные, за исключением '\', '-', ']' и символа '^',
                когда он является первым символом после '['.
                
[abc0-9Z]       Класс символов, в котором используется задание
                диапазона. Этот конкретный образец совпадёт с
                символами a, b, c, любой цифрой от 0 до 9 и символом
                Z. Диапазон задаётся указанием через дефис начального
                и конечного символов диапазона.
                
[^a-z\n]        Инвертированный класс. Регулярное выражение соответствует
                любому символу, не входящему в класс (в данном случае,
                любому символу, кроме символов от a до z и конца строки.
                
r*              0 или более вхождений r, где вместо r может быть любое
                регулярное выражение.
                
r+              1 или более вхождений r.

r?              0 или 1 вхождение r.
        
r{2,5}          От 2 до 5 вхождений r

r{2,}           2 или более вхождений r

r{4}            Ровно 4 вхождения r

{name}          Регулярное выражение, объявленное ранее под именем name

\X              Если X -- один из символов a, b, f, n, r, t или v, то
                символ '\X', как он определён в ANSI C (например,
                '\n' -- символ конца строки, а '\t' -- символ табуляции).
                В противном случае -- сам символ X, который интерпретируется
                как символ, даже если он имеет специальное значение.
                Например, выражение 1\* соответствует двум символам,
                '1' и '*'.

"ab[c-e]*"      Строка символов ab[c-e]* (обратите внимание, что символы,
                имеющие специальное значение, обрабатываются внутри строки
                так же, как и обычные).

<s>r            Соответствует регулярному выражению r, но только в случае,
                если текущим контекстом является s.

<<EOF>>         Конец файла

Другие допустимые элементы регулярных выражений описаны в документации flex.
                
В разделе правил перечисляются правила, имеющие вид

        <регулярное выражение> <действие>

Регулярное выражение должно начинаться с первого символа строки, перед ним
не должно быть пробелов и табуляции. Действие должно начинаться на той же
строке, что и регулярное выражение.

Перед первым правилом может идти фрагмент кода пользователя, используемый для
объявление локальных переменных функции, непосредственно исполняющей лексический
анализ. После последнего правила также может следовать фрагмент кода
пользователя, который будет исполняться каждый раз при входе в функцию
лексического анализа. Фрагменты кода должны быть заключены в скобки
%{ и %} или начинаться с пробелов или символов табуляции.

Все остальные фрагменты кода в блоке правил копируются в текст генерируемой
программы, но способ их обработки не определён и может стать причиной ошибки
при компиляции: эта возможность оставлена только для совместимости с lex,
и в описании лексического анализатора flex её использовать не следует.

Функция, которая выполняет лексический анализ, будет просматривать входной поток
символов и сопоставлять его с регулярными выражениями, соответствующими правилам.
Если какое-то регулярное выражение подойдёт, то функция выполнит соответствующее
действие. Если действие включает команду 'return X', то функция лексического
анализа вернёт значение X.

Идентификатор (FILE*) входного потока хранится в предопределённой
переменной yyin. Чтобы заставить flex читать текст из файла, нужно
открыть его для чтения как текстовый файл и присвоить его дескриптор
переменной yyin. В компиляторе Милана это делает основной модуль
программы.

Все правила рассматриваются одновременно: flex строит детерминированный
конечный автомат. В случае, если одной строке соответствуют несколько
правил, flex использует то, которое даст более длинное совпадение.
Если flex обнаруживает, что два правила дают совпадения одинаковой
длины, используется то правило, которое описано первым.
Эта особенность существенна при трансляции Милана: ключевые
слова Милана (BEGIN, END, IF, WHILE и другие) являются в то же время
допустимыми именами переменных. Поэтому правило, проверяющее совпадение
очередной подстроки с именем переменной, должно идти после правил,
определяющих ключевые слова: в противном случае они будут интерпретироваться
как переменные.

Действия обычно представляют собой код на языке C. Они заключаются в фигурные
скобки. В лексическом анализаторе Милана наиболее часто используемое действие
состоит в том, чтобы просто вернуть код лексемы, например:

        BEGIN                   { return T_BEGIN; }
        END                     { return T_END;   }
        IF                      { return T_IF;    }
        THEN                    { return T_THEN;  }

В данном случае константы T_BEGIN, T_END и другие определены в заголовочном
файле parser.tab.h (см. раздел "Синтаксический анализатор").

С некоторыми лексемами связаны дополнительные данные. Например, в Милане
любой целочисленное константе ставится в соответствие лексема T_INT.
Это делается для того, чтобы в синтаксическом анализаторе, который
затем будет разбирать поток лексем, можно было обойтись одним правилом
для обработки любых чисел. Чтобы различать разные числа, значение
очередного числа записывается в определённую в модуле синтаксического
анализатора переменную yylval. Синтаксический анализатор определяет
также и тип этой переменной. В синтаксическом анализаторе Милана
переменная yylval имеет тип union, включающий три поля:

        union {
                int integer;
                char *string;
                ast_node* ast;
        }

Поле integer предназначено для хранения целочисленных значений, связанных с
лексемами T_INT (целое число) и T_RELATION (операция отношения).
В случае лексемы T_INT в переменную yylval записывается число. В случае
T_RELATION -- код операции сравнения (0 для операции '=', 1 для '!=' и
так далее). Поле string предназначено для хранения указателя на имя
переменной. В компиляторе языка Милан используется таблица имён,
поэтому если два указателя на имя переменной равны, они соответствуют
одному и тому же имени. Поле ast в лексическом анализаторе не 
используется: оно нужно только в синтаксическом анализаторе.

Вот правила лексического анализатора Милана, в действиях которых
используется переменная yylval:

{EQ}                    { yylval.integer = 0; return T_RELATION; }
{NE}                    { yylval.integer = 1; return T_RELATION; }
{LT}                    { yylval.integer = 2; return T_RELATION; }
{GT}                    { yylval.integer = 3; return T_RELATION; }
{LE}                    { yylval.integer = 4; return T_RELATION; }
{GE}                    { yylval.integer = 5; return T_RELATION; }

{INT}                   { yylval.integer = atoi(yytext); return T_CONST;        }
{IDENT}                 { yylval.string = register_identifier(yytext); return T_IDENT; }

Переменная yytext содержит строку символов, удовлетворяющих регулярному
выражению. Переменная yyleng содержит длину этой строки.

Если правилу соответствует пустое действие, символам входного потока не
будет сопоставлено никакой лексемы: они просто будут проигнорированы.
Так, лексический анализатор Милана игнорирует пробелы:

        {WHITESPACE}

При этом пробелы, естественно, служат разделителями: ни одно регулярное
выражение, кроме {WHITESPACE} и регулярных выражений для комментария,
не включает пробельные символы и, соответственно, не может быть
сопоставлено со строкой, содержащей пробелы, табуляцию и символ
конца строки.

Отдельного описания требует обработка комментариев в лексическом анализаторе
Милана. Комментарий начинается с символов '/*'. Вот соответствующее
правило:

        "/*"                    BEGIN(comment);
        
Действие BEGIN(comment) вводит контекст с именем comment. Контекст определяет,
какие правила можно применять. По умолчанию используется контекст INITIAL,
в нём применимы все правила, в которых контекст не указан. В контексте
comment применимы только те правила, в которых в качестве контекста указан
comment. Таких правил три:

        <comment>[^*]*
        <comment>"*"+[^*/]*
        <comment>"*"+"/"        BEGIN(INITIAL);

Первое соответствует любому количеству символов, отличных от '*'. Такие символы
просто пропускаются. Второе правило соответствует одному или более символам
'*', за которыми следуют любые символы, кроме '*' и '/'. Они тоже игнорируются.
Наконец, третье правило соответствует комбинации символов '*/', которая завершает
комментарий. Связанное с этим правилом действие восстанавливает контекст INITIAL,
а сами символы пропускаются (также были пропущены и начальные символы комментария:
действия переключения конктеста используются только внутри лексического анализатора
и не влияют на то, какие данные получит синтаксический анализатор).

Действие yyterminate(), сопоставленное регулярному выражению <<EOF>>,
завершает работу лексического анализатора и возвращает значение 0,
означающее "лексем больше нет".

Раздел пользовательского кода может содержать произвольный исходный текст
на языке C, который без изменений копируется в файл сгенерированного
лексического анализатора. Этот код обычно содержит вспомогательные
функции, которые вызываются в процессе лексического анализа (например,
мы могли бы описать здесь функцию register_identifier, которая записывает
идентификатор в таблицу символов). Если этот блок отсутствует, можно
также опустить последние символы '%%'.

Более детальное описание работы лексического анализатора и его дополнительных
возможностей можно найти в документации flex.

Для того, чтобы сгенерировать лексический анализатор Милана, достаточно
выполнить команду

        flex lexer.l

В результате будет создан файл lex.yy.c (чтобы создать файл с другим именем,
можно использовать ключ командной строки -o; см. документацию flex).
Файл lex.yy.c содержит реализацию функции yylex. Синтаксический анализатор
вызывает эту функцию, чтобы получить очередную лексему.

= 4. Синтаксический анализатор =

Синтаксический анализатор разбирает поток лексем в соответствии с грамматикой
языка Милан. Лексемы являются терминальными символами.

В данном компиляторе Милана для построения синтаксического анализатора используется
генератор синтаксических анализаторов bison. Он совместим с известной программой
Yacc, но предоставляет больше возможностей и в настоящее время широко распространён.
bison строит синтаксические анализаторы на языке C для грамматик классов LR(1), LALR(1)
и GLR (Generalised LR) на основе описания грамматики.

Описание грамматики Милана находится в файле parser.y. Чтобы сгенерировать
синтаксический анализатор, достаточно выполнить команду

        bison -d parser.y

При этом будут созданы два файла: parser.tab.h и parser.tab.c. Если не использовать
ключ -d, то файл parser.tab.c не создаётся. Однако компилятор Милана построен
таким образом, что этот файл необходим: в нём определены значения, которые
используются для представления лексем. Файл parser.tab.h используется
лексическим анализатором, который по запросу синтаксического анализатора возвращает
лексему, соответствующую очередной подстроке входного файла.

Далее приведено краткое описание синтаксиса файла описания грамматики bison
с примерами, взятыми из описания грамматики языка Милан.

Описание грамматики имеет следующую структуру:

        %{
                Пролог
        %}

        Определения Bison

        %%

        Правила грамматики

        %%

        Эпилог

В прологе содержатся объявления типов, функций и переменных, которые будут
использоваться при выполнении синтаксического разбора. Здесь же подключаются
необходимые заголовочные файлы. В прологе необходимо объявить
функции yylex, которая реализует лексический анализ и возвращает
очередную лексему, и yyerror, выполняющую вывод сообщений об ошибках.
В компиляторе языка Милан функцию yylex реализует лексический анализатор,
построенный с помощью flex; в общем случае это не обязательно, и
лексический анализ может быть реализован вручную.

В разделе определений перечисляются терминальные и нетерминальные символы,
задаются приоритеты операций, описываются типы семантических атрибутов,
связанных с различными символами. Обсуждавшийся в разделе 4 тип переменной
yylval определён именно в этом разделе описания грамматики.

В разделе правил грамматики описаны правила вывода в грамматике и
семантические действия, связанные с каждым правилом. В компиляторе Милана
семантические действия состоят в построении абстрактного синтаксического
дерева, на основе которого в дальнейшем будет сгенерирован код.

В эпилоге может находиться произвольный код, который копируется в
файл синтаксического анализатора без изменений. Обычно здесь находятся
определения используемых в ходе синтаксического анализа функций (например,
функции yyerror). Если эпилог пуст, можно опустить символы '%%' перед ним.

Единственным необходимым разделом является раздел описания правил
грамматики. Таким образом, минимально допустимое описание грамматики
имеет вид:

        %%
        Правила грамматики

Разделителями являются пробелы, символы табуляции и конца строки. Там, где
допустим один разделитель, допустимо любое их количество. В любом месте
файла может быть расположен комментарий, ограниченный символами '/*' и
'*/'.

Правила имеют следующий синтаксис:

        <нетерминал> : <определение> { <действия> }
                     | <определение> { <действия> }
                     ...
                     ;

Правило всегда содержит по крайней мере одно определение и заканчивается
символом ';'. Правило с несколькими определениями соответствует набору
правил вывода с одинаковой левой частью (эта форма сокращённой записи
общепринята и используется, в том числе, в нашем курсе). Каждому
определению может соответствовать набор семантических действий (они не
обязательны). Вот пример корректного правила, взятый из описания грамматики
Милана:

expr : T_IDENT                  { $$ = new_var($1);                }
     | T_CONST                  { $$ = new_const($1);              } 
     | T_READ                   { $$ = new_read();                 }
     | expr '+' expr            { $$ = new_expr(OP_ADD, $1, $3);   }
     | expr '-' expr            { $$ = new_expr(OP_SUB, $1, $3);   }
     | expr '*' expr            { $$ = new_expr(OP_MUL, $1, $3);   }
     | expr '/' expr            { $$ = new_expr(OP_DIV, $1, $3);   }
     | '-' expr %prec T_NEG     { $$ = new_expr(OP_NEG, $2, NULL); }
     | '(' expr ')'             { $$ = $2;                         }
     ;


Здесь 'expr' -- имя нетерминального символа; T_IDENT, T_CONST, T_READ, T_NEG,
'+', '-', '*', '/', '(', ')' -- терминалы. Приведённое определение
соответствует следующему фрагменту грамматики:

        expr -> T_IDENT
        expr -> T_CONST
        expr -> T_READ
        expr -> expr + expr
        expr -> expr - expr
        expr -> expr * expr
        expr -> expr / expr
        expr -> expr + expr
        expr -> - expr
        expr -> ( expr )

Конструкция %prec позволяет указать приоритет операции "унарный минус",
устраняя возможную неоднозначность (использование приоритетов операций будет
описано далее).

Каждому правилу вывода в этом примере соответствует семантическое
действие. Функции new_var, new_const, new_read, new_expr создают
узлы абстрактного синтаксического дерева, соответствующие использованному
правилу. Например, если в процессе синтаксического разбора производится
свёртка, соответствующая правилу expr -> T_IDENT (то есть во входной цепочке
терминальный символ T_IDENT заменяется на нетерминал expr), то создаётся
новый узел абстрактного синтаксического дерева, имеющий тип
"переменная" и содержащий имя переменной. Как было описано в разделе
"Лексический анализатор", имя переменной связывается с лексемой T_IDENT
в ходе лексического анализа и становится доступным при синтаксическом
разборе.

Получить доступ к данным (атрибутам), связанным с каждым терминальным
или нетерминальными символом, следует возпользоваться предоставляемыми
Bison псевдопеременными. Псевдопеременные начинаются со знака '$',
за которым следует целое число -- порядковый номер символа в правой
части правила. Например, в конструкции

     | expr '*' expr            { $$ = new_expr(OP_MUL, $1, $3);   }

псевдопеременная $1 соответствует значению, связанному с первым вхождением
нетерминала expr, а $3 -- значению, связанному со вторым вхождением этого
же нетерминала.

Псевдопеременная $$ соответствует значению, связанному с нетерминальным
символом в левой части правила. Она используется для того, чтобы
связать с ним какой-либо атрибут, который обычно определяется, исходя
из значений атрибутов символов в левой части правила. В грамматике
языка Милан с символом, стоящим в левой части правила, связывается
указатель на узел абстрактного синтаксического дерева, построенного
при свёртке левой части правила.

Так как все нетерминальные символы,
за исключением нетерминала program, встречаются и в левой, и в правой
части каких-либо правил, фрагмент абстрактного синтаксического дерева,
построенного при выполнении одного действия и связанный с нетерминалом
в левой части правила, в другом действии сам станет поддеревом некоторого
узла. Таким образом, если исходный текст программы не содержит синтаксических
ошибок, результатом синтаксического анализа станет полностью построенное
абстрактное синтаксическое дерево программы, готовое к дальнейшей
обработке и генерации кода.

Каким образом bison узнаёт, является ли имя именем терминала или
именем нетерминала? Для этого служит раздел определений.
Все имена терминальных символов должны быть перечислены в разделе
определений с помощью деклараций %token, %left, %right или %nonassoc.
Декларация %token вводит терминальный символ без указания приоритета и
ассоциативности. Декларация %left вводит левоассоциативную лексему,
%right -- правоассоциативную, а %nonassoc -- лексему, для которой
ассоциативность не определена. 

Лексемы, объявленные с помощью
деклараций %left, %right и %nonassoc, имеют приоритет, который
определяется следующим образом. Приоритет лексем, которые объявлены
в рамках одной декларации, одинаков. Чем позже объявлена лексема,
тем выше её приоритет. В следующем примере:

        %left '+' '-'
        %left '*' '/'
        %left T_NEG

лексемы '+' и '-' имеют одинаковый приоритет, который меньше, чем у
лексем '*' и '/'. Их приоритет, в свою очередь, тоже одинаков и меньше,
чем у лексемы T_NEG. Лексема T_NEG имеет особый смысл в грамматике
языка Милан: она не используется непосредственно, а нужна только
для задания приоритета операции "унарный минус":

        expr: ...
            | '-' expr %prec T_NEG { $$ = new_expr(OP_NEG, $2, NULL); }

Конструкция %prec позволяет установить приоритет правила равным
приоритету лексемы, стоящей справа от %prec (в данном случае это
T_NEG, которая имеет наивысший приоритет).

Численные значения приоритетов не определяются: программист может
расставлять приоритеты, только выбирая порядок объявления лексем.

В качестве терминальных символов Bison допускает:
  - объявленные с помощью %token, %left, %right или %nonassoc
    терминалы, которые должны быть записаны заглавными буквами
    (например, T_BEGIN, T_END)
  - одиночные символы ('+', '-'): их необязательно объявлять заранее,
    если только с ними не связаны никакие атрибуты; предварительное
    объявление также даёт возможность указать приоритет и ассоциативность
    лексемы
  - цепочки символов, заключённые в двойные кавычки(":=").
  
Все остальные имена, встретившиеся в правилах грамматики, считаются
именами нетерминальных символов. Начальным нетерминалом считается
нетерминал, который стоит в левой части самого первого правила.
Это умолчание можно изменить с помощью директивы %start:
команда

        %start expr
        
назначит начальным нетерминалом символ expr.

Все нетерминальные символы должны быть определены, то есть имя
нетерминала должно находиться в левой части по крайней мере
одного правила. Допускается наличие нескольких правил с
одинаковой левой частью.

С терминальными и нетерминальными символами можно связать
значение атрибута. Тип этого значения определяется макросом
YYSTYPE, по умолчанию это int. Если типы атрибутов различных
символов могут быть разными, следует описать их в декларации
%union:

        %union {
                int integer;
                char* string;
                ast_node* ast;
        };

Эта декларация похожа на объявление union языка C: на самом деле,
при генерации синтаксического анализатора именно объединение языка
C и будет использоваться для представления атрибутов. Но в рамках
описания грамматики имена integer, string и ast играют роль
имён типов атрибутов, связанных с символом.

Если используются различные типы атрибутов, то для каждого символа,
с которым может быть связан атрибут, нужно указать "тип" (имя варианта
в %union). Для терминалов это делается при их объявлении:

        %token <integer> T_RELATION
        %token <string>  T_IDENT
        %token <integer> T_CONST

Для нетерминалов нужна отдельная декларация %type:

        %type <ast> program
        %type <ast> stmt_list
        %type <ast> stmt
        %type <ast> rest_if
        %type <ast> cond
        %type <ast> expr

После того, как типы определены для всех символов, где это необходимо,
bison может сгенерировать правильный код для обработки атрибутов.
Обратите внимание, что при использовании переменных $$, $1, $2, ...
не нужно обращаться к полям объединения: это обращение сгенерирует
bison. Тип псевдопеременных $$, $1, ... соответствует варианту, который
был указан при определении соответствующего символа. Например, в
правиле

stmt_list : stmt               { $$ = $1;                                        }
          | stmt ';' stmt_list { tmp_ast = $1; tmp_ast->next = $3; $$ = tmp_ast; }

псевдопеременные $1, $3, $$ содержат значение типа ast_node*, поскольку
нетерминалам stmt и stmt_list был приписан "тип" ast. При этом, однако, нельзя
напрямую обратиться к полю $1->next: компилятор ничего не знает о связи
между структурой ast_node и псевдопеременной $1.

5. Абстрактное синтаксическое дерево

В ходе синтаксического анализа программа на языке Милан преобразуется во
внутреннее представление, называемое абстрактным синтаксическим деревом.
В этом представлении уже нет данных о конкретном синтаксисе программы.
Каждый узел дерева содержит сведения о выражении или операторе программы,
а в его потомках содержатся данные о составных частях выражения или оператора.
Выполняя рекурсивный обход дерева, можно интерпретировать программу или
генерировать соответствующий ей машинный код.

Например, выражение 2 * (4 + 3) можно представить в виде абстрактного
синтаксического дерева следующим образом:

        *
       / \
      2   +
         / \
        4   3

Абстрактное синтаксическое дерево похоже на дерево разбора, но отличается
от него: во-первых, оно в явном виде хранится в памяти, во-вторых, оно
содержит только полезные данные, необходимые для дальнейшей обработки программы.

Узел абстрактного синтаксического дерева Милана описывается с помощью
структуры ast_node:

typedef struct ast_node_struct {
        node_type type;

        union {
                int integer_value;
                char* string_value;
                struct ast_node_struct* ast_value;
        } data;

        struct ast_node_struct* next;
        struct ast_node_struct* sub[2];
} ast_node;

Поле type идентифицирует тип узла синтаксического дерева. Возможные варианты
определяются следующим перечислением:

typedef enum {
        Node_Block = 0,
        Node_Const,
        Node_Var,
        Node_Read,
        Node_Expr,
        Node_Assign,
        Node_Write,
        Node_Cond,
        Node_If,
        Node_While
} node_type;

Им соответствуют:

        Node_Block      -- последовательность операторов между BEGIN и END,
                           DO и OD, THEN и ELSE, THEN и FI или ELSE и FI.

        Node_Const      -- целочисленная константа
        Node_Var        -- переменная
        Node_Read       -- Инструкция чтения со стандартного ввода
        Node_Expr       -- арифметическое выражение
        Node_Assign     -- оператор присваивания
        Node_Write      -- оператор вывода на стандартный вывод
        Node_Cond       -- логическое выражение
        Node_If         -- условный оператор
        Node_While      -- оператор цикла WHILE

Каждый узел содержит связанное с ним значение data, указатель на
соседний узел next и два указателя на узлы-потомки sub[2].
Интерпретация этих значений зависит от типа узла.

Поле data является объединением и должно интерпретироваться
в зависимости от того, значение какого типа должно в нём находиться.
Это определяется значением поля type.

!!! В дальнейшем изложении для простоты словосочетания вроде "указатель на узел,
!!! соответствующий оператору" будет написано просто "указатель на оператор".

Для каждого узла, соответствующего оператору (Node_Assign, Node_Write,
Node_Cond, Node_If, Node_While) в поле next содержится либо указатель
на следующий за ним оператор в блоке, либо NULL. Для всех остальных --
NULL.

Для узла Node_Block поле sub[0] содержит указатель на первый оператор блока.
Значение поля data не определено. В поле sub[1] находится NULL.

Для узла Node_Const в поле data находится целочисленное значение константы.
Значения sub[0] и sub[1] равны NULL.

Для узла Node_Var в поле data содержится указатель на идентификатор в таблице
символов (тип char*), в полях sub[0] и sub[1] -- NULL.

Для узла Node_Read в полях sub[0] и sub[1] находится NULL, значение поля
data не определено.

Для узла Node_Expr в поле data находится код операции, в поле sub[0] --
указатель на первый операнд, в поле sub[1] -- указатель на второй операнд.
Допустимые коды операций:

typedef enum {
        OP_ADD = 0, /* Сложение */
        OP_SUB,     /* Вычитание */
        OP_MUL,     /* Умножение */
        OP_DIV,     /* Деление */
        OP_NEG      /* Унарный минус */
} operation;

Если код операции равен OP_NEG, то в поле sub[1] находится NULL.
Операндом может быть узел абстрактного синтаксического дерева, имеющий
тип Node_Expr, Node_Const, Node_Var или Node_Read.

Для узла Node_Assign в поле data находится указатель на имя переменной,
которой присваивается значение (char*), в поле sub[0] -- указатель на выражение
(узел типа Node_Expr, Node_Const, Node_Var или Node_Read), в поле sub[1] -- NULL.

Для узла Node_Write значение поля data не определено, в поле sub[0]
находится указатель на выражение, значение которого нужно напечатать
(Node_Expr, Node_Const, Node_Var, Node_Read), в поле sub[1] -- NULL.

Для узла Node_Cond в поле data находится код операции сравнения,
в sub[0] -- указатель на первый аргумент, в sub[1] -- указатель на второй
аргумент. Допустимы следующие операции сравнения:

typedef enum {
        C_EQ = 0, /* = */
        C_NE,     /* != */
        C_LT,     /* < */
        C_GT,     /* > */
        C_LE,     /* <= */
        C_GE      /* >= */
} comparison;

Агрументам соответствуют узлы типов Node_Expr, Node_Var, Node_Const или Node_Read.

Для узла Node_If в узле data содержится указатель на узел типа Node_Cond, который
задаёт проверяемое условие. В поле sub[0] находится указатель на блок (узел
Node_Block) THEN, выполняемый, если условие истинно. В поле sub[1] -- указатель
на блок, исполняемый, если условие ложно.

Для узла Node_While в поле data также находится указатель на условие, которое
проверяется перед каждым входом в тело цикла. В поле sub[0] находится указатель на
блок, содержащий тело цикла (типа Node_Block), в sub[1] -- NULL.

Для создания узлов предусмотрен набор функций, каждая из которых соответствует
одному типу узла. В качестве аргументов эти функции получают необходимые для
создания узла данные. Каждая функция возвращает указатель на
вновь созданный узел абстрактного синтаксического дерева.
Вот список функций, их аргументов и соответствующих им
типов узлов:

----------------------------------------------------------------
Узел      : Node_Block:
Функция   : ast_node* new_block(ast_node* arglist)
Аргументы : указатель на узел, соответствующий первому оператору
            блока. В поле next этого узла должен находиться
            указатель на следующий оператор блока, и так далее.
            Значение поля next у последнего узла в списке
            должно быть равно NULL.
----------------------------------------------------------------
Узел      : Node_Const
Функция   : ast_node* new_const(int v)
Аргументы : Значение константы (целое число).
----------------------------------------------------------------
Узел      : Node_Var
Функция   : ast_node* new_var(char* v)
Аргументы : Имя переменной
----------------------------------------------------------------
Узел      : Node_Read
Функция   : ast_node* new_read()
Аргументы : нет.
----------------------------------------------------------------
Узел      : Node_Expr
Функция   : ast_node* new_expr(operation op, ast_node* arg1, ast_node* arg2)
Аргументы : op -- код арифметической операции (OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_NEG)
            arg1 -- указатель на узел, соответствующий первому аргументу операции
            arg2 -- указатель на узел, соответствующий второму аргументу операции
                    (если op == OP_NEG, то arg2 должен быть равен NULL).
            В качестве аргументов могут выступать узлы типов Node_Const, Node_Var,
            Node_Read и Node_Expr.
----------------------------------------------------------------
Узел      : Node_Assign
Функция   : ast_node* new_assign(char* var, ast_node* arg)
Аргументы : var -- имя переменной
            arg -- указатель на узел, соответствующий присваиваемому значению.
----------------------------------------------------------------
Узел      : Node_Cond
Функция   : ast_node* new_cond(comparison comp, ast_node* arg1, ast_node* arg2)
Аргументы : comp -- код операции сравнения (C_EQ, C_NE, C_LT, C_GT, C_LE, C_GE)
            arg1 -- указатель на узел, соответствующий первому аргументу
            arg2 -- указатель на узел, соответствующий второму агрументу
----------------------------------------------------------------
Узел      : Node_Write
Функция   : ast_node* new_write(ast_node* expr)
Аргументы : указатель на узел, соответствующее которому значение нужно распечатать.
            Это может быть узел типа Node_Const, Node_Var, Node_Read, Node_Expr.
----------------------------------------------------------------
Узел      : Node_If
Функция   : ast_node* new_if(ast_node* cond, ast_node* arg1, ast_node* arg2)
Аргументы : cond -- указатель на узел, представляющий условие (типа Node_Cond)
            arg1 -- указатель на узел, соответствующий оператору или блоку операторов
                    в части THEN (для простоты всегда используется Node_Block)
            arg2 -- указатель на узел, соответствующий оператору или блоку операторов
                    в части ELSE, или NULL, если часть ELSE отсутствует (также всегда
                    используется Node_Block)
----------------------------------------------------------------
Узел      : Node_While
Функция   : ast_node* new_while(ast_node* cond, ast_node* arg)
Аргументы : cond -- указатель на узел, представляющий условие (Node_Cond)
            arg -- указатель на узел, соответствующий телу цикла (для простоты
            всегда используется Node_Block).
----------------------------------------------------------------

Во всех случаях, когда возможен один оператор или список операторов,
создаётся узел типа Node_Block, в поле sub[0] которого помещается
указатель на первый или единственный оператор блока. Второй оператор
блока можно получить, обратившись к полю next первого оператора, и так далее.
Таким образом, независимо от количества операторов в списке, всегда
создаётся узел типа Node_Block.

Для выполнения отладочной печати абстрактного синтаксического дерева предназначена
функция dump_ast(FILE*, ast_node*). Она получает в качестве первого аргумента
идентификатор потока, куда будет выведено дерево, а в качестве второго -- указатель
на первый узел синтаксического дерева. Функция dump_ast вызывает рекурсивную функцию
dump_ast_proc, которая анализирует тип очередного узла, выводит сведения о нём в
поток и при необходимости вызывает саму себя для того, чтобы вывести на печать
поддеревья. Для распечатки списков (то есть узлов, которые содержат ненулевой
указатель в поле next) предусмотрена специальная функция dump_ast_list.
Она в цикле просматривает все узлы списка, пока не дойдёт до последнего.
Для каждого узла вызывается общая функция печати dump_ast_proc.

Чтобы освободить память, занимаемую абстрактным синтаксическим деревом, используется
функция free_ast(ast_node*). Она принимает в качестве аргумента указатель на корень
синтаксического дерева и рекурсивно обходит дерево, освобождая занятую узлами память.

Когда синтаксический анализатор выполняет свёртку к нетерминальному символу, он выполняет
связанный с правилом код. Этот код вызывает функцию построения узла абстрактного
синтаксического дерева, тип которого соответствует нетерминалу в левой части правила.
В качестве необходимых аргументов используются значения, связанные с терминалами и
нетерминалами из левой части правила. Таким образом дерево строится "снизу вверх",
начиная с узлов, соответствующих константам и переменным, которые объединяются
в логические и арифметические выражения, а те становятся частями более сложных
операторов. Когда, наконец, применяется правило, в левой части которого находится
нетерминал program, построение абстрактного синтаксического дерева завершается, а
указатель на него записывается в глобальную переменную parse_result.

= 6. Генератор кода =

Построенное в результате синтаксического анализа абстрактное синтаксическое дерево
используется для генерации кода. Для этого кодогенератор рекурсивно обходит дерево
и для каждого узла порождает набор команд виртуальной машины Милана, соответствующий
типу узла и содержащимся в нём данным. Рассмотрим, например, следующее синтаксическое
дерево (в упрощённой записи), соответствующее выражению 6 * (4 + 3):

      *
     / \
    6   +
       / \
      4   3

Виртуальная машина Милана -- это стековая машина.
Команды забирают свои аргументы из стека и помещают в стек результат работы.
Поэтому чтобы выполнить операцию умножения, необходимо сначала поместить
в стек значения обоих аргументов, а затем выполнить команду умножения.
В результате на вершине стека окажется результат умножения. Теперь его можно
использовать как аргумент при выполнении новых команд.

Обход дерева начинается с корня, то есть с узла, содержащего '*'. Этот узел
соответствует операции умножения (узел типа Node_Expr с data = OP_MUL),
применяемой к двум аргументам, константе 6 (Node_Const, data = 6) и
результату сложения (Node_Expr, data = OP_ADD) констант 4 (Node_Const, data = 4)
и 3 (Node_Const, data = 3). 

Чтобы сгенерировать код для корневого узла, нужно:
  - Сгенерировать код для вычисления первого аргумента
  - Сгенерировать код для вычисления второго аргумента
  - Добавить команду MULT, которая перемножит аргументы

Первому аргументу соответствует левое поддерева корневого узла: (Node_Const, data = 6).
Так как этот аргумент -- константа, то сгенерированный код должен просто затолкнуть в стек
значение 6:

        PUSH 6

Код для вычисления второго аргумента генерируется точно так же, как и для корня, только
вместо команды умножения нужно использовать сложение:

        PUSH 4
        PUSH 3
        ADD

Таким образом, полностью код, вычисляющий значение выражения 6 * (4 + 3), будет
выглядеть, с точностью до адресов команд, так:

        0: PUSH 6
        1: PUSH 4
        2: PUSH 3
        3: ADD
        4: MULT

Первые три команды заталкивают в стек константы 6, 4 и 3 соответственно.
Команда ADD забирает из стека два верхних значения (3 и 4), складывает их
и результат (7) заталкивает в стек. Команда MULT забирает из стека два
верхних значения (7 и 6) и заталкивает в стек результат их умножения (42).
Таким образом, на стеке оказывается результат вычисления -- число 42.

Команды исполняются виртуальной машиной Милана последовательно в порядке
возрастания адресов, поэтому необходимо присваивать каждой команде правильный
адрес. Это можно легко сделать, если передавать функции, генерирующей код,
адрес очередной свободной ячейки в памяти команд. При каждом рекурсивном
вызове функции генерации кода этот аргумент будет устанавливаться с учётом
уже использованных ячеек, поэтому при обработке каждого узла будет известно,
где в памяти команд будет размещён соответствующий этому узлу код.

Каждому типу узла соответствует своё правило генерации кода. Перечислим эти
правила.

Для узла Node_Block необходимо в цикле сгенерировать код для каждого узла,
соответствующего очередному оператору блока. При этом если последняя машинная
команда очередного узла размещена в ячейке X, то первую команду следующего
оператора нужно разместить по адресу X + 1.

Для узла Node_Const необходимо сгенерировать команду PUSH с аргументом,
равным значению константы.

Для узла Node_Var нужно сгенерировать команду LOAD, в качестве аргумента
которой указав адрес в памяти данных, по которому размещена переменная.
Команда LOAD поместит значение, расположенное по этому адресу, в стек.

Для узла Node_Read нужно сгенерировать команду INPUT без аргументов.

Для узла Node_Expr надо вначале сгенерировать команды, вычисляющие значения
аргументов арифметической операции, а потом сгенерировать команду, которая
выполняет саму эту операцию (ADD, SUB, MULT, DIV или INVERT). Указатели на
узлы, соответствующие аргументам, хранятся в самом узле (поля sub[0] и sub[1]).

Для узла Node_Write нужно сначала сгенерировать команды, вычисляющие значение
распечатываемого выражения (Node_Const, Node_Var, Node_Read или Node_Expr),
а потом -- команду PRINT.

Код для узла Node_Cond генерируется аналогично узлу Node_Expr, только вместо
арифметических команд используется команда COMPARE. В качестве её аргумента
используется код операции сравнения (0 для EQ, 1 для NE, 2 для LT, 3 для GT,
4 для LE, 5 для GE).

Узлы Node_If и Node_While обрабатываются немного сложнее. Сначала генерируется
код, вычисляющий значение условия (Node_Cond). Затем нужно сгенерировать оператор
условного перехода, который передаст управление за пределы цикла (для Node_While)
или в начало блока ELSE (Node_If), если условие окажется ложным. Проблема состоит
в том, что код для тела цикла (или блока THEN) ещё не был сгенерирован, его длина
неизвестна, поэтому мы просто не знаем, куда нужно передать управление!

Эту проблему можно легко решить, воспользовавшись особенностью виртуальной машины
Милана: читая список команд, она размещает их в памяти не в порядке их поступления,
а в порядке их адресов. Например, последовательность команд

        2: ADD
        1: PUSH 33
        0: PUSH 9
        3: PRINT

с точки зрения виртуальной машины Милана ничем не отличается от

        0: PUSH 9
        1: PUSH 33
        2: ADD
        3: PRINT

А раз так, то можно сначала сгенерировать тело цикла (или блок THEN),
и только затем -- команду перехода по адресу, следующему за этим блоком. А этот
адрес будет уже известен! Для того, чтобы это стало возможным, нужно только сохранить
адрес "пропущенной" команды перехода во временной переменной.

Рассмотрим детально способ генерации команд для узлов Node_While и Node_If.

Для узла Node_While:

        1. Пусть нужно разместить код цикла, начиная с ячейки X. Запомним этот
           адрес во временной переменной tmpaddr1: tmpaddr1 = X.
        2. Сгенерируем код для проверки условия цикла. Пусть последняя команда
           этого кода находится в ячейке Y.
        3. Запомним значение Y + 1 во временной переменной tmpaddr2:
           tmpaddr2 = Y + 1.
        4. Сгенерируем код, выполняющий тело цикла. Пусть последняя команда этого
           кода находится в ячейке Z.
        5. Генерируем команду безусловного перехода в начало цикла,
           на проверку условия. Адрес перехода нам известен: он сохранён в tmpaddr1.
                (Z + 1): JUMP tmpaddr1
        6. Генерируем команду выхода из цикла, если условие не выполнено. Она должна
           быть размещена по адресу tmpaddr2:
                tmpaddr2: JUMP_NO (Z + 2)
        7. Конец

Для узла Node_If:

        1. Сгенерируем код проверки условия. Пусть его последняя команда занимает
           ячейку X. Запомним в переменной tmpaddr1 адрес следующей ячейки:
           tmpaddr1 = X + 1.
        2. Сгенерируем код блока THEN. Пусть его последняя команда находится в
           ячейке Y.
        3. Сгенерируем команду перехода на блок ELSE, если условие не выполнено:
                tmpaddr1: JUMP_NO (Y + 2)
        4. Запомним адрес Y + 1 в переменной tmpaddr1.
        5. Сгенерируем код блока ELSE. Пусть его последняя команда находится в
           ячейке Z.
        6. Сгенерируем команду перехода за пределы условного оператора. Она должна
           быть помещена после блока THEN и перед блоком ELSE, чтобы в случае,
           если условие было истинным, не выполнять блок ELSE. Именно для этой
           команды было оставлено место в пункте 3 алгоритма (отсюда "странный" адрес
           Y + 2):
                tmpaddr1: JUMP (Z + 1)
        7. Конец

Компилятор Милана генерирует код с помощью рекурсивной функции generate_code.
Она выводит производимый код в поток вывода, идентификатор которого передаётся
в качестве аргумента. Другими аргументами являются адрес в памяти команд, начиная
с которого будет размещён код, и указатель на узел абстрактного синтаксического
дерева, для которого генерируется код.

Если указатель на узел не равен NULL, функция анализирует тип узла и генерирует
соответствующий ему код. generate_code возвращает адрес первой свободной
ячейки в памяти команд после генерации кода для узла.

Кроме generate_code используется также вспомогательная функция generate_command.
Она генерирует одну указанную команду с заданным адресом. Именно она используется
для генерации команд перехода в узлах Node_If и Node_While.

Имена переменных с их адресами в памяти данных связываются с помощью функции
get_var_address(ast_node*). Она принимает в качестве аргумента указатель на узел
абстрактного синтаксического дерева и возвращает адрес переменной.
В текущей реализации для этого просто вызывается функция find_name (определённая
в файле ident.c и объявленная в ident.h). Она возвращает индекс переменной в
глобальной таблице символов. Однако нетрудно изменить реализацию функции
get_var_address таким образом, чтобы она использовала другие данные об узле
синтаксического дерева. Например, в узле можно хранить указатель на
используемую таблицу символов, и использовать различные таблицы символов
для внешних и вложенных блоков. Такой подход позволяет достаточно просто
реализовать статическую область видимости переменных и организовать поддержку
локальных переменных во вложенных блоках и функциях, а также рекурсию.

Управление таблицей имён реализовано в файле ident.c. В заголовочном файле
ident.h объявлены функции:

char* register_identifier(char *name);
        -- записывает идентификатор в таблицу символов и возвращает указатель
           на него. При этом проверяется, нет ли такого идентификатора в таблице.
           Если он есть, то возвращается указатель на него, иначе создаётся новая
           запись. Благодаря этому равенство указателей влечёт за собой равенство
           идентификаторов.

void print_id_table(FILE *);
        -- выводит таблицу идентификаторов в формате виртуальной машины Милана
           (команда SET). Адресом переменной является её порядковый номер в таблице
           символов. Каждой переменной присваивается значение 0.

int find_name(char *name);
        -- возвращает адрес переменной с именем, записанным в строке name, или -1,
           если такой переменной в таблице символов нет. В качестве ардеса
           используется порядковый номер в таблице символов.

= 7. Объединяем всё вместе =

Все компоненты компилятора Милана соединяются вместе в файле milan.c. В нём реализованы:

        - Анализ параметров командной строки (функции parse_arguments и parse_arg)
        - Функция main, которая реализует цикл работы компилятора:

        1. Поприветствовать пользователя
        2. Выполнить разбор параметров командной строки и записать результаты
           в структуру данных config; туда же записываются дескрипторы файлов,
           которые компилятор открывает для чтения или записи.
        3. Переменной yyin присваивается дескриптор потока, откуда лексический
           анализатор будет читать текст программы.
        4. Вызывается синтаксический анализатор (yyparse()). Если он возвращает
           значение 0, то разбор закончился успешно, и в переменной parse_result
           находится указатель на абстрактное синтаксическое дерево.
        5. Если разбор прошёл успешно, то:
                - В выходной поток печатается таблица переменных (функцией print_id_table).
                - Вызывается функция генерации кода generate_program, которая также
                  печатает код в выходной поток.
           В противном случае печатается сообщение об ошибке.

        6. Все открытые файлы закрываются и программа завершается.

